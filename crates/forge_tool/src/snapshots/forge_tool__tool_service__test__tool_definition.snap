---
source: crates/forge_tool/src/tool_service.rs
expression: "serde_json::to_string_pretty(&tools).unwrap()"
---
[
  {
    "name": "apply_patch",
    "description": "Replace sections in a file using SEARCH/REPLACE blocks for precise\nmodifications.\n\n<<<<<<< SEARCH\n[exact content to find]\n=======\n[new content to replace with]\n>>>>>>> REPLACE\n\nRules:\n1. SEARCH must match exactly (whitespace, indentation, line endings)\n2. Each block replaces first match only\n3. Keep blocks minimal - include only changing lines plus needed context\n4. Complete lines only - no truncation\n5. For moves: use 2 blocks (delete + insert)\n6. For deletes: use empty REPLACE section\n\nExample:\n<<<<<<< SEARCH\ndef old_function(x):\n    return x + 1\n=======\ndef new_function(x, y=0):\n    return x + y\n>>>>>>> REPLACE\n\nParameters:\n- diff (required): SEARCH/REPLACE blocks defining changes\n- path (required): File path relative to the current working directory",
    "input_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "FSReplaceInput",
      "type": "object",
      "required": [
        "diff",
        "path"
      ],
      "properties": {
        "diff": {
          "description": "SEARCH/REPLACE blocks defining changes",
          "type": "string"
        },
        "path": {
          "description": "File path relative to the current working directory",
          "type": "string"
        }
      }
    },
    "output_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "FSReplaceOutput",
      "type": "object",
      "required": [
        "content",
        "path"
      ],
      "properties": {
        "content": {
          "type": "string"
        },
        "path": {
          "type": "string"
        },
        "syntax_checker": {
          "type": [
            "string",
            "null"
          ]
        }
      }
    }
  },
  {
    "name": "execute_command",
    "description": "Execute shell commands with safety checks and validation. This tool provides\n controlled access to system shell commands while preventing dangerous\n operations through a comprehensive blacklist and validation system.\n The tool also enforces a timeout to prevent long-running commands from\n blocking the system.\n\nParameters:\n- command (required): The shell command to execute.\n- cwd (required): The working directory where the command should be executed.",
    "input_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ShellInput",
      "type": "object",
      "required": [
        "command",
        "cwd"
      ],
      "properties": {
        "command": {
          "description": "The shell command to execute.",
          "type": "string"
        },
        "cwd": {
          "description": "The working directory where the command should be executed.",
          "type": "string"
        }
      }
    },
    "output_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ShellOutput",
      "type": "object",
      "required": [
        "success"
      ],
      "properties": {
        "stderr": {
          "type": [
            "string",
            "null"
          ]
        },
        "stdout": {
          "type": [
            "string",
            "null"
          ]
        },
        "success": {
          "type": "boolean"
        }
      }
    }
  },
  {
    "name": "file_information",
    "description": "Request to retrieve detailed metadata about a file or directory at the\n specified path. Returns comprehensive information including size, creation\n time, last modified time, permissions, and type. Use this when you need to\n understand file characteristics without reading the actual content.\n\nParameters:\n- path (required): The path of the file or directory to inspect (relative to the current working directory)",
    "input_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "FSFileInfoInput",
      "type": "object",
      "required": [
        "path"
      ],
      "properties": {
        "path": {
          "description": "The path of the file or directory to inspect (relative to the current working directory)",
          "type": "string"
        }
      }
    },
    "output_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "String",
      "type": "string"
    }
  },
  {
    "name": "learning",
    "description": "Whenever the agent learns something new, agent should call learning tool\n so that learning can be stored and referred for future conversations.\n Each learning represents a piece of information that was discovered or\n clarified during the conversation, such as:\n - User\\'s coding style preferences\n - Project-specific requirements or constraints\n - Technical decisions and their rationale\n - Important context about the codebase\n\nParameters:\n- learnings (required): List of learnings to store. Each string should be a clear and concise statement capturing a single piece of information learned during the conversation.",
    "input_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "LearningInput",
      "type": "object",
      "required": [
        "learnings"
      ],
      "properties": {
        "learnings": {
          "description": "List of learnings to store. Each string should be a clear and concise statement capturing a single piece of information learned during the conversation.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "output_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "String",
      "type": "string"
    }
  },
  {
    "name": "list_directory_content",
    "description": "Request to list files and directories within the specified directory. If\n recursive is true, it will list all files and directories recursively. If\n recursive is false or not provided, it will only list the top-level\n contents. Do not use this tool to confirm the existence of files you may\n have created, as the user will let you know if the files were created\n successfully or not.\n\nParameters:\n- path (required): The path of the directory to list contents for (relative to the current working directory)\n- recursive: Whether to list files recursively. Use true for recursive listing, false or omit for top-level only.",
    "input_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "FSListInput",
      "type": "object",
      "required": [
        "path"
      ],
      "properties": {
        "path": {
          "description": "The path of the directory to list contents for (relative to the current working directory)",
          "type": "string"
        },
        "recursive": {
          "description": "Whether to list files recursively. Use true for recursive listing, false or omit for top-level only.",
          "type": [
            "boolean",
            "null"
          ]
        }
      }
    },
    "output_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_String",
      "type": "array",
      "items": {
        "type": "string"
      }
    }
  },
  {
    "name": "outline",
    "description": "List definition names (classes, functions, methods, etc.) in source code\n files. This tool is particularly useful when you need to:\n - Map relationships between types, traits, and interfaces\n   - See inheritance hierarchies in object-oriented code\n   - Identify trait implementations in Rust\n   - Understand class composition patterns\n - Analyze architectural patterns:\n   - Discover service/component dependencies\n   - Find implementation details of interfaces\n   - Track type usage across modules\n - Navigate large codebases:\n   - Quickly find relevant type definitions\n   - Understand module organization\n   - Locate specific implementations\n Supports multiple programming languages:\n - Rust (.rs files): structs, traits, impls\n - JavaScript (.js files): classes, methods, prototypes\n - Python (.py files): classes, decorators, inheritance\n - TypeScript (.ts, .tsx files): interfaces, classes, methods\n - Scala (.scala files): traits, classes, objects\n - Java (.java files): classes, methods, interfaces\n - CSS (.css files): classes, ids, pseudo-classes\n Returns a formatted string showing file names and their definitions in a\n tree-like structure. Example output:\n ```text\n models.rs\n │trait Repository<T>\n │struct UserRepository\n |----\n │impl Repository<User> for UserRepository\n ```\n\nParameters:\n- path (required): The path to the directory containing the source code files to analyze.",
    "input_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "OutlineInput",
      "type": "object",
      "required": [
        "path"
      ],
      "properties": {
        "path": {
          "description": "The path to the directory containing the source code files to analyze.",
          "type": "string"
        }
      }
    },
    "output_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "String",
      "type": "string"
    }
  },
  {
    "name": "read_file",
    "description": "Request to read the contents of a file at the specified path. Use this when\n you need to examine the contents of an existing file you do not know the\n contents of, for example to analyze code, review text files, or extract\n information from configuration files. Automatically extracts raw text from\n PDF and DOCX files. May not be suitable for other types of binary files, as\n it returns the raw content as a string.\n\nParameters:\n- path (required): The path of the file to read (relative to the current working directory)",
    "input_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "FSReadInput",
      "type": "object",
      "required": [
        "path"
      ],
      "properties": {
        "path": {
          "description": "The path of the file to read (relative to the current working directory)",
          "type": "string"
        }
      }
    },
    "output_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "String",
      "type": "string"
    }
  },
  {
    "name": "search_in_files",
    "description": "Request to perform a regex search across files in a specified directory,\n providing context-rich results. This tool searches for patterns or specific\n content across multiple files, displaying each match with encapsulating\n context.\n\nParameters:\n- file_pattern: Glob pattern to filter files (e.g., '*.ts' for TypeScript files). If not provided, it will search all files (*).\n- path (required): The path of the directory to search in (relative to the current working directory). This directory will be recursively searched.\n- regex (required): The regular expression pattern to search for. Uses Rust regex syntax.",
    "input_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "FSSearchInput",
      "type": "object",
      "required": [
        "path",
        "regex"
      ],
      "properties": {
        "file_pattern": {
          "description": "Glob pattern to filter files (e.g., '*.ts' for TypeScript files). If not provided, it will search all files (*).",
          "type": [
            "string",
            "null"
          ]
        },
        "path": {
          "description": "The path of the directory to search in (relative to the current working directory). This directory will be recursively searched.",
          "type": "string"
        },
        "regex": {
          "description": "The regular expression pattern to search for. Uses Rust regex syntax.",
          "type": "string"
        }
      }
    },
    "output_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Array_of_String",
      "type": "array",
      "items": {
        "type": "string"
      }
    }
  },
  {
    "name": "think_step",
    "description": "A framework for iterative reasoning in problem-solving.\n Purpose:\n Tracks reasoning steps (\\\"thoughts\\\") to solve complex problems:\n - Breaks tasks into steps\n - Supports revisions and branching\n - Tracks confidence and verifies solutions\n Key Features:\n - Adjust `total_thoughts` for complexity\n - Link revisions with `revises_thought`\n - Branch paths via `branch_from_thought`\n - Update `solution_confidence`\n - Mark completion with `solution_reached`\n Workflow:\n 1. Initialize `Think` with `total_thoughts`.\n 2. Add steps to `thought_history`.\n 3. Revise or branch as needed.\n 4. Update confidence and validate.\n 5. Mark `solution_reached` when done.\n Fields:\n - `thought_history`: Steps taken.\n - `branches`: Alternate paths.\n - `solution_reached`: Final solution.\n\nParameters:\n- branch_from_thought: The number of the thought from which this thought branches, if this is a branch.\n- branch_id: A unique identifier for the branch, if this is a branch.\n- is_revision: Whether this thought is a revision of a previous thought.\n- needs_more_thoughts: Whether additional thoughts are needed to reach a solution.\n- next_thought_needed (required): Whether another thought is needed to reach a solution.\n- revises_thought: The number of the thought being revised, if this is a revision.\n- solution_confidence: The current confidence in the solution, ranging from 0.0 to 1.0.\n- thought (required): The description of the current thought or reasoning step.\n- thought_number (required): The number of the current thought or reasoning step.\n- total_thoughts (required): The total number of thoughts or reasoning steps expected to reach a solution.",
    "input_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ThoughtInput",
      "type": "object",
      "required": [
        "next_thought_needed",
        "thought",
        "thought_number",
        "total_thoughts"
      ],
      "properties": {
        "branch_from_thought": {
          "description": "The number of the thought from which this thought branches, if this is a branch.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        },
        "branch_id": {
          "description": "A unique identifier for the branch, if this is a branch.",
          "type": [
            "string",
            "null"
          ]
        },
        "is_revision": {
          "description": "Whether this thought is a revision of a previous thought.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "needs_more_thoughts": {
          "description": "Whether additional thoughts are needed to reach a solution.",
          "type": [
            "boolean",
            "null"
          ]
        },
        "next_thought_needed": {
          "description": "Whether another thought is needed to reach a solution.",
          "type": "boolean"
        },
        "revises_thought": {
          "description": "The number of the thought being revised, if this is a revision.",
          "type": [
            "integer",
            "null"
          ],
          "format": "int32"
        },
        "solution_confidence": {
          "description": "The current confidence in the solution, ranging from 0.0 to 1.0.",
          "type": [
            "number",
            "null"
          ],
          "format": "float"
        },
        "thought": {
          "description": "The description of the current thought or reasoning step.",
          "type": "string"
        },
        "thought_number": {
          "description": "The number of the current thought or reasoning step.",
          "type": "integer",
          "format": "int32"
        },
        "total_thoughts": {
          "description": "The total number of thoughts or reasoning steps expected to reach a solution.",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "output_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ThoughtResult",
      "type": "object",
      "required": [
        "branches",
        "next_thought_needed",
        "solution_confidence",
        "solution_reached",
        "thought_history_length",
        "thought_number",
        "total_thoughts"
      ],
      "properties": {
        "branches": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "next_thought_needed": {
          "type": "boolean"
        },
        "solution_confidence": {
          "type": "number",
          "format": "float"
        },
        "solution_reached": {
          "type": "boolean"
        },
        "thought_history_length": {
          "type": "integer",
          "format": "uint",
          "minimum": 0.0
        },
        "thought_number": {
          "type": "integer",
          "format": "int32"
        },
        "total_thoughts": {
          "type": "integer",
          "format": "int32"
        }
      }
    }
  },
  {
    "name": "user_confirmation",
    "description": "The approve tool provides an interactive confirmation dialog for critical\n operations. Use this tool when a simple yes/no answer is sufficient for\n to proceed with its decision-making.\n # Use Cases\n - Confirming destructive operations (file deletions, data modifications)\n - Validating important user decisions\n - Ensuring user awareness before significant actions\n - Getting explicit consent for sensitive operations\n # Behavior\n - Displays a yes/no dialog with the provided message\n - Default selection is \\'yes\\' for quick confirmations\n - Interactive: requires direct user input\n - Returns true only on explicit \\'yes\\' confirmation\n\nParameters:\n- message (required): The message to display when asking for confirmation",
    "input_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ApproveInput",
      "description": "Input parameters for the approve tool",
      "type": "object",
      "required": [
        "message"
      ],
      "properties": {
        "message": {
          "description": "The message to display when asking for confirmation",
          "type": "string"
        }
      }
    },
    "output_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Boolean",
      "type": "boolean"
    }
  },
  {
    "name": "user_options",
    "description": "The select tool provides an interactive selection dialog for choosing from\n multiple options. Use this tool when you need the user to choose one item\n from a list of possibilities.\n # Use Cases\n - Selecting from multiple available options\n - Making configuration choices\n - Choosing between different paths of action\n - Filtering or narrowing down possibilities\n # Behavior\n - Displays a selection dialog with the provided message and options\n - Interactive: user can navigate through options using arrow keys\n - Returns the selected option as a string\n - Supports keyboard navigation and search\n - Best used with multiple options to provide meaningful choices\n\nParameters:\n- message (required): The message to display above the selection options\n- options (required): The list of options to choose from. Intended for multiple options (2 or more) to provide meaningful choices to the user.",
    "input_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "SelectInput",
      "description": "Input parameters for the select tool",
      "type": "object",
      "required": [
        "message",
        "options"
      ],
      "properties": {
        "message": {
          "description": "The message to display above the selection options",
          "type": "string"
        },
        "options": {
          "description": "The list of options to choose from. Intended for multiple options (2 or more) to provide meaningful choices to the user.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "output_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "String",
      "type": "string"
    }
  },
  {
    "name": "write_file",
    "description": "Request to write content to a file at the specified path. If the file\n exists, it will be overwritten with the provided content. If the file\n doesn\\'t exist, it will be created. This tool will automatically create any\n directories needed to write the file.\n\nParameters:\n- content (required): The content to write to the file. ALWAYS provide the COMPLETE intended content of the file, without any truncation or omissions. You MUST include ALL parts of the file, even if they haven't been modified.\n- path (required): The path of the file to write to (relative to the current working directory)",
    "input_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "FSWriteInput",
      "type": "object",
      "required": [
        "content",
        "path"
      ],
      "properties": {
        "content": {
          "description": "The content to write to the file. ALWAYS provide the COMPLETE intended content of the file, without any truncation or omissions. You MUST include ALL parts of the file, even if they haven't been modified.",
          "type": "string"
        },
        "path": {
          "description": "The path of the file to write to (relative to the current working directory)",
          "type": "string"
        }
      }
    },
    "output_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "FSWriteOutput",
      "type": "object",
      "required": [
        "content",
        "path"
      ],
      "properties": {
        "content": {
          "type": "string"
        },
        "path": {
          "type": "string"
        },
        "syntax_checker": {
          "type": [
            "string",
            "null"
          ]
        }
      }
    }
  }
]
