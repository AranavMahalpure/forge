---
source: crates/forge_repomap/src/tests.rs
expression: map
---
src/file/git.rs:
⋮...
|
|impl GitWalker {
|    pub async fn read_files(&self, root: &Path) -> Result<HashMap<String, Vec<u8>>> {
|        let mut files = HashMap::new();
|        let walker = Walker::max().cwd(root.to_path_buf());
|        
|        let entries = walker.get().await
|            .map_err(|e| FileError::Git(e.to_string()))?;
|
|        let p = entries.iter().filter(|e| !e.is_dir);
|
|        for entry in p {
|            
⋮...

src/graph.rs:
⋮...
|pub struct ReferenceGraph {
|    graph: DiGraph<String, f64>,
|    node_indices: HashMap<String, NodeIndex>,
|    edge_to_ident: HashMap<EdgeIndex, String>,
|    ranked_definitions: RankedDefinitionsMap,
|    sorted_definitions: Vec<RankedDefinition>,
⋮...
|impl ReferenceGraph {
|    pub fn new() -> Self {
|        Self {
|            graph: DiGraph::new(),
|            node_indices: HashMap::new(),
|            edge_to_ident: HashMap::new(),
|            ranked_definitions: HashMap::new(),
|            sorted_definitions: Vec::new(),
|        }
|    }
|
|    pub fn get_graph(&self) -> &DiGraph<String, f64> {
|        &self.graph
⋮...
|    pub fn populate_from_symbol_index(
|        &mut self,
|        symbol_index: &SymbolIndex,
|        mentioned_idents: &HashSet<String>,
⋮...
|    pub fn calculate_page_ranks(&self) -> Vec<f64> {
|        page_rank(&self.graph, 0.85, 1)
⋮...
|    pub fn get_sorted_definitions(&self) -> &[RankedDefinition] {
|        &self.sorted_definitions
⋮...
|    pub fn calculate_and_distribute_ranks(&mut self) {
|        let ranks = self.calculate_page_ranks();
|        self.distribute_rank(&ranks);
|        self.sort_by_rank();
⋮...
|    fn sort_by_rank(&mut self) {
|        let mut vec: Vec<_> = self.ranked_definitions.iter().collect();
|        vec.sort_by(|a, b| b.1.partial_cmp(a.1).unwrap_or(std::cmp::Ordering::Equal));
|        self.sorted_definitions = vec.into_iter().map(|(k, v)| (k.clone(), *v)).collect();
⋮...
|    fn distribute_rank(&mut self, ranked: &Vec<f64>) {
|        for src in self.graph.node_indices() {
|            let src_rank = ranked[src.index() as usize];
|            let total_outgoing_weights: f64 = self.graph.edges(src).map(|edge| *edge.weight()).sum(
|
|            for edge in self.graph.edges(src) {
|                let destination = edge.target();
|                let weight = *edge.weight();
|                let new_weight = src_rank * weight / total_outgoing_weights;
|
|                let edge_index = edge.id();
⋮...
|    fn get_or_create_node(&mut self, name: &str) -> NodeIndex {
|        *self.node_indices
|            .entry(name.to_string())
|            .or_insert_with(|| self.graph.add_node(name.to_string()))
⋮...
|    fn calculate_multiplier(&self, symbol: &str, mentioned_idents: &HashSet<String>) -> f64 {
|        if mentioned_idents.contains(symbol) {
|            10.0
|        } else if symbol.starts_with('_') {
|            0.1
|        } else {
|            1.0
|        }
⋮...

src/helpers.rs:
⋮...
|pub fn close_small_gaps_helper(
|    lines: HashSet<usize>,
|    code_split_by_lines: Vec<String>,
|    code_len: usize,
⋮...

src/symbol.rs:
⋮...
|pub struct SymbolIndex {
|    pub defines: HashMap<String, HashSet<PathBuf>>,
|    pub references: HashMap<String, Vec<PathBuf>>, // Using Vec to maintain order of references
|    pub definitions: HashMap<(PathBuf, String), HashSet<Symbol>>,
|    pub common_symbols: HashSet<String>,
|    pub file_to_symbols: HashMap<PathBuf, HashSet<(PathBuf, String)>>,
|    pub path: PathBuf,
⋮...
|impl SymbolIndex {
|    pub fn new(path: &Path) -> Self {
|        Self {
|            defines: HashMap::new(),
|            references: HashMap::new(),
|            definitions: HashMap::new(),
|            common_symbols: HashSet::new(),
|            file_to_symbols: HashMap::new(),
|            path: path.to_path_buf(),
|        }
⋮...
|    fn process_file(&self, fname: &str, content: &[u8], config: &'static LanguageSyntaxConfig) -> R
|            
|        let rel_path = self.get_rel_fname(&PathBuf::from(fname));
|        let mut symbols = Vec::new();
|        
|        // Create QueryEngine for handling both definition and reference queries
|        let mut query_engine = QueryEngine::from_config(config)
|            .map_err(|e| RepoMapError::ParseError(e.to_string()))?;
|
|
⋮...
|    pub fn add_symbol(&mut self, symbol: Symbol, rel_path: &PathBuf) {
|        match symbol.kind {
|            SymbolKind::Definition => {
|                self.defines
|                    .entry(symbol.name.clone())
|                    .or_default()
|                    .insert(rel_path.clone());
|                self.definitions
|                    .entry((rel_path.clone(), symbol.name.clone()))
|                    .or_default()
|                    .insert(symbol.clone());
⋮...
|    pub fn post_process_symbols(&mut self) {
|        self.process_empty_references();
|        self.process_common_symbols();
⋮...
|    pub fn get_rel_fname(&self, fname: &PathBuf) -> PathBuf {
|        fname
|            .strip_prefix(&self.path)
|            .unwrap_or(fname)
|            .to_path_buf()
⋮...

src/tree_context.rs:
⋮...
|impl<'a> TreeContext<'a> {
|    pub fn new(code: String, fs_file_path: String) -> Self {
|        // let ts_parsing = TSLanguageParsing::init();
|        // let config = ts_parsing.for_file_path(&filename).unwrap().clone();
|        let lines: Vec<String> = code.lines().map(|s| s.to_string()).collect();
|        let num_lines = lines.len() + 1;
|        Self {
|            _filename: fs_file_path,
|            parent_context: true,
|            child_context: false,
⋮...
|    pub fn init(&mut self, cursor: TreeCursor<'a>) {
|        self.walk(cursor);
|        self.arrange_headers();
⋮...
|    pub fn walk(&mut self, mut cursor: TreeCursor<'a>) {
|        // It is dfs in a way
|        loop {
|            let start_line = cursor.node().start_position().row;
|            let end_line = cursor.node().end_position().row;
|            let size = end_line - start_line;
|
|            self.nodes[start_line].push(cursor.node());
|
|            if size > 0 {
⋮...
|    pub fn add_lois(&mut self, lois: Vec<usize>) {
|        self.lois.extend(lois);
⋮...
|    pub fn add_context(&mut self) {
|        if self.lois.is_empty() {
|            return;
|        }
|
|        self.show_lines = self.lois.clone();
|
|        if self.loi_pad > 0 {
|            // for each interesting line
|            for line in self.show_lines.clone().iter() {
⋮...
|    pub fn format(&self) -> String {
|        if self.show_lines.is_empty() {
|            return String::new();
|        }
|
|        let mut cloned_show_lines = self.show_lines.clone().into_iter().collect::<Vec<_>>();
|        cloned_show_lines.sort();
|
|        let mut output = String::new();
|
⋮...
|    pub fn add_parent_scopes(&mut self, index: usize, recurse_depth: Vec<usize>) {
|        if self.done_parent_scopes.contains(&index) {
|            return;
|        }
|
|        self.done_parent_scopes.insert(index);
|
|        // here for the scopes we are getting the headers and then figuring out
|        // the first header (or the biggest one which we want to keep for the scope)
|        if self.scopes.get(index).is_none() {
⋮...

src/tree_walker.rs:
⋮...
|impl TreeWalker {
|    pub fn new(config: LanguageSyntaxConfig, code: String) -> Self {
|        let num_lines = code.lines().count() + 1;
|        Self {
|            config,
|            code,
|            lines_of_interest: HashSet::new(),
|            nodes: (0..num_lines).map(|_| Vec::new()).collect(),
|            scopes: vec![HashSet::new(); num_lines],
|            header: vec![Vec::new(); num_lines],
⋮...
|    pub fn walk(&self, file_path: &Path) -> Result<String, RepoMapError> {
|        let mut parser = self.config.parser()
|            .map_err(|e| RepoMapError::ParseError(e.to_string()))?;
|            
|        let parsed = parser.parse(self.code.as_bytes())
|            .map_err(|e| RepoMapError::ParseError(e.to_string()))?;
|
|        let cursor = parsed.tree().root_node().walk();
|        let mut context = TreeContext::new(
|            self.code.clone(),
⋮...
